# 2018-12-24 API

This doc gives a very immature design for a spec based server and client implementation, 
the following are not goals in this version because they are too hard.

- generate code for other languages/frameworks
- stream, either http based stream (i.e. stream of json using long connection or server send event) or websocket
- gRPC
- cross project
- auth

In terms of language agnostic spec, there are two examples [grpc](https://grpc.io/docs/) using [protobuf](https://developers.google.com/protocol-buffers/) 
and [OpenAPI](https://github.com/OAI/OpenAPI-Specification) (v2 is swagger 2.0) using [json schema](https://json-schema.org/).

The problem of grpc is document the behavior of the API and content inside the message is not first class,
so extra effort is needed to remind people to write doc and keep it up to date.
This is solved by API definition tool like swagger, where you define model and api endpoints in a YAML file and 
you can generate stub from it. However the generation is optional, people can write api as they used to and 
try to keep the swagger.yaml up to date, which is requires a lot human effort and is error prone.

In Kubernetes, user define struct in go, and scan go file to generate a bunch of things [including swagger](https://github.com/kubernetes/kube-openapi/blob/master/pkg/generators/openapi.go).
I think this is the ideal approach for a go project where the go code serves as single source of truth and the the synchronization is single direction,
from go code to doc/swagger/protobuf and to other language.

There are existing go web framework like [goadesign/goa](https://github.com/goadesign/goa) which is design based, 
support generating swagger and they are working on gRPC integration as well. However I am not a big fan of its DSL,
which reminds me of ginkgo, I'd rather have POGS (Plain Old Go Struct) instead of the 'builder' pattern and a bunch
of callbacks.

Current design have two directions, one is using simple go struct with tag and annotation where the struct you define
is the struct you use, another is using complex go struct as definition struct and use a generated struct in application code.
The second one is very similar to write swagger definitions, but it is written in go and is used to generate go code,
also the generator may become a bit tricky when multi packages is involved, not sure if adding a `package` field will fix it.

````go
// use the struct defined
type Task struct {
	   Id string `ice:"required"`
}

// use the definition to generate struct
var TaskDef = Def{
	  Package: "github.com/dyweb/ice/udash/task",
	  Type: "struct",
	  Fields: []Field{
	  	{
	  		Name: "Name",
	  		Type: "string"
	  		Pattern: "[0-9]+"
	  	}
	  }
}

generator.Add(TaskDef)
generator.Gen()
````

## Ref

- [readme.io Difference between swagger 3.0 and swagger 2.0](https://blog.readme.io/an-example-filled-guide-to-swagger-3-2/)
  - https://readme.io/ is a more advanced swagger UI, with code example in different languages
- https://github.com/kubernetes/kube-openapi/blob/master/pkg/generators/openapi.go
  - this produce the binary `openapi-gen` included in kubebuilder
- https://github.com/kubernetes/gengo A package for generating things based on go files. This mechanism was first used in Kubernetes and is split out here for ease of reuse and maintainability
- https://github.com/emicklei/go-restful found when looking at kube api gen, very java ...
- https://github.com/go-openapi/spec/issues/21 used by openapi-gen but only support v2
  - https://github.com/go-courier/oas support v3
- https://json-schema.org/learn/getting-started-step-by-step.html an example of json schema